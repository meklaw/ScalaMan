package ru.meklaw
package lectures.week2oop

object CaseClasses {
  def main(args: Array[String]): Unit = {
    /*Обычные классы стоит избегать и вот почему:
    * с case классом понятно, что от него можно ожидать
    * - иммутабельность
    * - поэлементное сравнение
    * - возможность копирования
    * - вывод в консоли, в читабельном виде
    * Одной из основных идей функционального программирования является то,
    *  что мы стараемся разделить структуры данных и операции над ними.
    * Т.е. все функции обычно сбрасываются в трейты и объекты, но никак не в обычные классы
    *  (их вообще желательно избегать, если того позволяет бизнес-логика вашего приложения,
    *  прибегая к case классам).
    *
    * параметры класса по умолчанию являются val, что дает доступ к ним без доп манипуляций
    * Информация сразу выводится в понятном виде (toString)
    * equals сравнивает по параметрам case class изначально
    * в то время как обычные классы сравнивают только ссылку
    * позволяет копировать экземпляр класса, так и скопировать с изменённым аргументом конструктора
    * */
    case class Person(name: String, occupation: String)

    val bob = Person("Bob", "Developer")

    val anotherBob = bob.copy()
    println(bob) // Person(Bob,Developer)
    println(anotherBob) // Person(Bob,Developer)

    val bobsTwin = bob.copy(name = "John")
    val bobsTwin2 = bob.copy("John")
    println(bobsTwin) // Person(John,Developer)

    /*Любой case класс имеет объект-компаньон
    * В таком объекте-компаньоне всегда присутствует метод apply. Которым можно воспользоваться и сделать так:
    * подобный apply всегда доступен, даже если создан другой*/
    val alice = Person("Alice", "Engineer") // метод apply в действии
  }
}
